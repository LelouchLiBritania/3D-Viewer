{"version":3,"sources":["../../../src/lib/parse-las.ts"],"names":["Schema","getMeshBoundingBox","LASFile","getLASSchema","parseLAS","arrayBuffer","options","parseLASMesh","pointIndex","positions","colors","intensities","classifications","originalHeader","lasMesh","loader","loaderData","schema","header","vertexCount","boundingBox","attributes","topology","mode","parseLASChunked","las","skip","decoder","lasHeader","total","totalToRead","PositionsType","fp64","Float64Array","Float32Array","pointsFormatId","Uint8Array","Uint16Array","POSITION","value","size","intensity","classification","COLOR_0","batchSize","pointsCount","scale","scaleX","scaleY","scaleZ","offset","offsetX","offsetY","offsetZ","twoByteColor","detectTwoByteColors","colorDepth","i","position","color","getPoint","meshBatch","totalRead","progress","onProgress","rawData","onParseData","dataHandler","open","getHeader","Unpacker","getUnpacker","Math","ceil","max","chunk","readData","count","versionAsString","isCompressed","unpacker","buffer","hasMoreData","e","close","console","warn"],"mappings":"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","sourcesContent":["// ported and es6-ified from https://github.com/verma/plasio/\nimport type {ArrowTable, ColumnarTable} from '@loaders.gl/schema';\nimport type {LASLoaderOptions} from '../las-loader';\nimport type {LASMesh, LASHeader} from './las-types';\nimport {Schema, getMeshBoundingBox /* , convertMesh */} from '@loaders.gl/schema';\nimport {LASFile} from './laslaz-decoder';\nimport {getLASSchema} from './get-las-schema';\n\ntype LASChunk = {\n  count: number;\n  buffer: ArrayBuffer;\n  hasMoreData: boolean;\n  versionAsString?: string;\n  isCompressed?: boolean;\n};\n\n/**\n * Parsing of .las file\n * @param arrayBuffer\n * @param options\n * @returns LASHeader\n */\nexport default function parseLAS(\n  arrayBuffer: ArrayBuffer,\n  options?: LASLoaderOptions\n): LASMesh | ArrowTable | ColumnarTable {\n  return parseLASMesh(arrayBuffer, options);\n  // This code breaks pointcloud example on the website\n  // const mesh = parseLASMesh(arrayBuffer, options);\n  // return convertMesh(mesh, options?.las?.shape || 'mesh') as LASMesh | ArrowTable | ColumnarTable;\n}\n\n/**\n * Parsing of .las file\n * @param arrayBuffer\n * @param options\n * @returns LASHeader\n */\nfunction parseLASMesh(arrayBuffer: ArrayBuffer, options: LASLoaderOptions = {}): LASMesh {\n  let pointIndex: number = 0;\n\n  let positions: Float32Array | Float64Array;\n  let colors: Uint8Array | null;\n  let intensities: Uint16Array;\n  let classifications: Uint8Array;\n  let originalHeader: any;\n\n  const lasMesh: LASMesh = {\n    loader: 'las',\n    loaderData: {} as LASHeader,\n    // shape: 'mesh',\n    schema: new Schema([]),\n    header: {\n      vertexCount: 0,\n      boundingBox: [\n        [0, 0, 0],\n        [0, 0, 0]\n      ]\n    },\n    attributes: {},\n    topology: 'point-list',\n    mode: 0 // GL.POINTS\n  };\n\n  /* eslint-disable max-statements */\n  // @ts-ignore Possibly undefined\n  parseLASChunked(arrayBuffer, options.las?.skip, (decoder: any = {}, lasHeader: LASHeader) => {\n    if (!originalHeader) {\n      originalHeader = lasHeader;\n      const total = lasHeader.totalToRead;\n\n      const PositionsType = options.las?.fp64 ? Float64Array : Float32Array;\n      positions = new PositionsType(total * 3);\n      // laslaz-decoder.js `pointFormatReaders`\n      colors = lasHeader.pointsFormatId >= 2 ? new Uint8Array(total * 4) : null;\n      intensities = new Uint16Array(total);\n      classifications = new Uint8Array(total);\n\n      lasMesh.loaderData = lasHeader;\n      lasMesh.attributes = {\n        POSITION: {value: positions, size: 3},\n        // non-gltf attributes, use non-capitalized names for now\n        intensity: {value: intensities, size: 1},\n        classification: {value: classifications, size: 1}\n      };\n\n      if (colors) {\n        lasMesh.attributes.COLOR_0 = {value: colors, size: 4};\n      }\n    }\n\n    const batchSize = decoder.pointsCount;\n    const {\n      scale: [scaleX, scaleY, scaleZ],\n      offset: [offsetX, offsetY, offsetZ]\n    } = lasHeader;\n\n    const twoByteColor = detectTwoByteColors(decoder, batchSize, options.las?.colorDepth);\n\n    for (let i = 0; i < batchSize; i++) {\n      const {position, color, intensity, classification} = decoder.getPoint(i);\n\n      positions[pointIndex * 3] = position[0] * scaleX + offsetX;\n      positions[pointIndex * 3 + 1] = position[1] * scaleY + offsetY;\n      positions[pointIndex * 3 + 2] = position[2] * scaleZ + offsetZ;\n\n      if (color && colors) {\n        if (twoByteColor) {\n          colors[pointIndex * 4] = color[0] / 256;\n          colors[pointIndex * 4 + 1] = color[1] / 256;\n          colors[pointIndex * 4 + 2] = color[2] / 256;\n        } else {\n          colors[pointIndex * 4] = color[0];\n          colors[pointIndex * 4 + 1] = color[1];\n          colors[pointIndex * 4 + 2] = color[2];\n        }\n        colors[pointIndex * 4 + 3] = 255;\n      }\n\n      intensities[pointIndex] = intensity;\n      classifications[pointIndex] = classification;\n\n      pointIndex++;\n    }\n\n    const meshBatch = {\n      ...lasMesh,\n      header: {\n        vertexCount: lasHeader.totalRead\n      },\n      progress: lasHeader.totalRead / lasHeader.totalToRead\n    };\n\n    options?.onProgress?.(meshBatch);\n  });\n  /* eslint-enable max-statements */\n\n  lasMesh.header = {\n    vertexCount: originalHeader.totalToRead,\n    boundingBox: getMeshBoundingBox(lasMesh?.attributes || {})\n  };\n\n  if (lasMesh) {\n    lasMesh.schema = getLASSchema(lasMesh.loaderData, lasMesh.attributes);\n  }\n  return lasMesh;\n}\n\n/**\n * parse laz data\n * @param rawData\n * @param skip\n * @param onParseData\n * @return parsed point cloud\n */\n/* eslint-enable max-statements */\nexport function parseLASChunked(rawData: ArrayBuffer, skip: number, onParseData: any = {}): void {\n  const dataHandler = new LASFile(rawData);\n\n  try {\n    // open data\n    dataHandler.open();\n\n    const header = dataHandler.getHeader();\n    // start loading\n    const Unpacker = dataHandler.getUnpacker();\n\n    const totalToRead = Math.ceil(header.pointsCount / Math.max(1, skip));\n    header.totalToRead = totalToRead;\n    let totalRead = 0;\n\n    /* eslint-disable no-constant-condition */\n    while (true) {\n      const chunk: LASChunk = dataHandler.readData(1000 * 100, 0, skip);\n\n      totalRead += chunk.count;\n\n      header.totalRead = totalRead;\n      header.versionAsString = chunk.versionAsString;\n      header.isCompressed = chunk.isCompressed;\n\n      const unpacker = new Unpacker(chunk.buffer, chunk.count, header);\n\n      // surface unpacker and progress via call back\n      // use unpacker.pointsCount and unpacker.getPoint(i) to handle data in app\n      onParseData(unpacker, header);\n\n      if (!chunk.hasMoreData || totalRead >= totalToRead) {\n        break;\n      }\n    }\n  } catch (e) {\n    throw e;\n  } finally {\n    dataHandler.close();\n  }\n}\n\n/**\n * @param decoder\n * @param batchSize\n * @param colorDepth\n * @returns boolean\n */\nfunction detectTwoByteColors(\n  decoder: any = {},\n  batchSize: number,\n  colorDepth?: number | string\n): boolean {\n  let twoByteColor = false;\n  switch (colorDepth) {\n    case 8:\n      twoByteColor = false;\n      break;\n    case 16:\n      twoByteColor = true;\n      break;\n    case 'auto':\n      if (decoder.getPoint(0).color) {\n        for (let i = 0; i < batchSize; i++) {\n          const {color} = decoder.getPoint(i);\n          // eslint-disable-next-line max-depth\n          if (color[0] > 255 || color[1] > 255 || color[2] > 255) {\n            twoByteColor = true;\n          }\n        }\n      }\n      break;\n    default:\n      // eslint-disable-next-line\n      console.warn('las: illegal value for options.las.colorDepth');\n      break;\n  }\n  return twoByteColor;\n}\n"],"file":"parse-las.js"}